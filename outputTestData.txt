1:	Mr. Wachs Computer Science testing started.................................................
2:	Computer Science 42SAP starting............................................................
3:	Computer Science 42SAP curriculum content starting.........................................
4:	AP curriculum - Part 1 Test started........................................................
5:	AP: Unit 1 (Primitive Types) started.......................................................
6:	// 1.1 Why Programming? Why Java?
7:	...
8:	System.out.print outputs text to the screen and System.out.println outputs with a line break
9:	...
10:	More specifically, the code word "System" refers to the "computer system" and the 
11:	word "out" refers to outputting, and finally the word "print" or "println" are calls to 
12:	methods (or "actions") that take the string literal (which is the word or words in between 
13:	the quotation marks) and outputs it. So the command "System.out.println("literal");" 
14:	will take the string literal and output it to the default output device - that being the 
15:	computer screen.
16:	...
17:	// 1.2 Variables and Data Types
18:	...
19:	Data/information refers to the "kind" of data being stored (or "remembered") by the program 
20:	in a "variable". A variable is a piece of the computer's memory (storage) that has a "name" 
21:	(or "address") so that the programmer can refer to it by that name. The "type" refers to the 
22:	"kind" of data that you are storing (e.g. text, numbers, true/false, etc.). The type must be 
23:	specified at the time you write a line of code to "create" (or "declare") the variable. A 
24:	variable can only be one type and only store that specified type of data. However, the data 
25:	itself can change (or "vary") after the initial declaration. Examples of this are below...
26:	...
27:	// Variables declared and assigned initial ("starting") values:
28:	boolean a = true;
29:	int     b = 0;
30:	double  c = 1.0;
31:	char    d = 'A';
32:	// Variables content changes ("reassigned"):
33:	a = false;
34:	b = 1;
35:	c = 1.1;
36:	d = 'B';
37:	...
38:	A "final" (or a "constant") is a variable in which the stored value does NOT change 
39:	(it stays "constant") and it locked at that value. Final (or constant) variables are 
40:	given the initial value when declared (or initialized) and that value stays locked. These 
41:	types of values are written in ALL_CAPS with the underscore value used to seperate words in 
42:	the name. Final variables are more efficient for a number of reasons including ease of code 
43:	understanding, speed (faster code), easier to update code, and others. Examples of finals 
44:	are below...
45:	// Constants (finals) declared (initialized)
46:	final boolean FOUND  = true;
47:	final int     VALUE  = 1;
48:	final double  AMOUNT = 2.5;
49:	final char    CODE   = 'X';
50:	...
51:	// 1.3 Expressions and Assignment Statements
52:	...
53:	Arithmetic (or "math") statements in code are lines of code (or "statements") that are 
54:	written to evaluate (or "solve") an equation of logic the program needs to solve. In this 
55:	context, the word "literal" can also mean a number (like "5"). This usually involves 
56:	variable types int and double (the number types) used in a math expression or equation. This 
57:	can involve math operations like +, -, *, / and % (modulus). When multiple int values are 
58:	evaluated in a formula, they always evaluate to an int answer (solution) and double values 
59:	will evaluate to a double. Complex (or "compound" expressions can be formed in which 
60:	the order of operations (or precedence order). This means multiplication and division are 
61:	evaluated before addition and subtraction. If operations are at the same precedence level, 
62:	then they are evaluated from left to right.When you try and divide by zero, an error 
63:	(the "ArithmeticException" error) will occur and the program will stop running. Examples:
64:	...
65:	// Arithmetic evaluations using variables
66:	int    v1 = 5;
67:	int    v2 = 3;
68:	int    v3 = (v1 + 5 * v2 / (1 + 2)) % 2;
69:	double v4 = 5.2;
70:	double v5 = 3.3;
71:	double v6 = (v4 + 5.1 * v5 / (1.2 + 2.3)) % 2.2;
72:	...
73:	// 1.4 Compound Assignment Operators
74:	...
75:	Compound statements in this context refers to using shortcuts to quickly add or subtract one 
76:	(increment or decrement) to a variable. You can also use more complex shorthand compound 
77:	statements to quickly multiply, divide, even modulus a variable with itself or other 
78:	variables. For example:
79:	...
80:	// Shorthand Compound Arithmetic expressions
81:	int value = 5;
82:	value++;    // is the same as "value = value + 1;"
83:	value--;    // is the same as "value = value + 1;"
84:	value += 5; // is the same as "value = value + 5;"
85:	value -= 5; // is the same as "value = value - 5;"
86:	value *= 5; // is the same as "value = value * 5;"
87:	value /= 5; // is the same as "value = value / 5;"
88:	value %= 5; // is the same as "value = value % 5;"
89:	...
90:	// 1.5 Casting and Ranges of Variables
91:	...
92:	Casting is the process of "converting" one data type into another data type. When casting 
93:	an double to a int, the decimal portion of the double is truncated (cut off) and not rounded 
94:	off. When a int is cast to a double, the int is "widened" to now accomodate any decimals. 
95:	A char when cast will turn into it's ASCII value. The process of casting involves putting 
96:	variable to be cast with the type being cast into in round brackets to the left of that 
97:	variable. Integer values hold a finite amount of number space (4 bytes) and the built-in 
98:	constants Integer.MAX_VALUE and MIN_VALUE are the limits of the int. If an expression 
99:	evaluates an int outside that range, an error will occur (overflow error). For example:
100:	...
101:	// Casting data types
102:	int integer = Integer.MAX_VALUE;
103:	double doub = Double.MIN_VALUE;
104:	doub        = (int)integer;
105:	integer     = (int)doub;
106:	char letter = 'A';
107:	integer     = (int)letter;
108:	...
109:	AP: Unit 1 (Primitive Types) completed!....................................................
110:	AP: Unit 3 (Boolean Expressions And If Statements) started.................................
111:	// 3.1 Boolean Expressions
112:	...
113:	A Boolean (true/false) expression is a code statement most likely in a control structure 
114:	like a conditional statement or loop control structure that evaluates to true or false to 
115:	make decisions and control the flow of the program. The Boolean expression will require 
116:	the use of relational operators like: < , > , <= , >= , == , and != those being: "less 
117:	than", "greater than", "less than or equal to", "greater than or equal to", "equal 
118:	to", and "not equal to".
119:	...
120:	// 3.2 if Statements and Control Flow
121:	...
122:	A "Conditional Statement" is also known under other names like "branching statement", "if 
123:	statement", "one-way selection statement", and "control structure". It uses the reserved 
124:	keyword "if" along with round brackets which contain the Boolean expression, and curly 
125:	brackets to contain the control block of all code you wish to be controlled by the 
126:	conditional statement. Brackets are optional if the block is only one line, and you may also 
127:	move thos lines up to the same line as the conditional statement. For example:
128:	...
129:	// Example of if statements
130:	int a = 10;
131:	int b = 10;
132:	if (a == a) {
133:	    // "equal"
134:	}
135:	...
136:	// 3.3 if-else Statements
137:	...
138:	The "else" statement is paired with an "if" statement to control the flow of the logic so 
139:	that the conditional now evaluates to both true and false. This can be called a "two 
140:	way selection" (for true/false). An "else" must always follow an "if" statement first. 
141:	For example:
142:	...
143:	// if with "else" 
144:	double c = 1.45, d = 1.5; 
145:	if (c < d) {
146:	    // "Less than"
147:	}
148:	else {
149:	    // "Greater than"
150:	}
151:	// Shortened lines version
152:	char e = 'A';
153:	char f = 'a';
154:	if (e != f) e = '!';
155:	else        e = '=';
156:	...
157:	// 3.4 else if Statements
158:	...
159:	When making multiple decisions (more than 2), the "else if" statement is added to an 
160:	existing "if" statement to have multiple branches of logic for the code to follow. This 
161:	is much more efficient than seperate "if" statements. This can also be called "multi-way 
162:	selection" (or "if-else-if"). An "else" statement is also still the final option (but 
163:	this is not required). For example:
164:	...
165:	// Showing a "chain" of else if statements
166:	int g = 0;
167:	if (g == 1) {
168:	    // The first if is true
169:	}
170:	else if (g == 2) {
171:	    // The next if is true
172:	}
173:	else if (g == 3) {
174:	    // The next if (in the "chain" of ifs) is true
175:	}
176:	else {
177:	    // Nothing above is true, so go to this else
178:	}
179:	...
180:	// 3.5 Compound Boolean Expressions
181:	...
182:	The process of "nesting" means to place one conditional statement inside the "block" of 
183:	another conditional statement. The logical operators: "and", "or", and "not" are 
184:	represented with the symbols: "&&" (and), "||" (or), and "!" (not). The operator AND 
185:	is used to combine logical boolean expressions such that ALL expressions need to be true for 
186:	the entire statement to be true. The operator OR is used to combine logical boolean 
187:	expressions such that ANY expression can be true for the entire statement to be true. The 
188:	operator NOT reverses the logic so that true statements are evaluated as false (and visa 
189:	versa). If the statement contains multiple Boolean expressions and the result of the 
190:	evaluation of one expression has already determined the expressions result, then the 
191:	rest of the expressions do not need to be evaluated - this is known as a "short-circuited 
192:	evaluation". For example:
193:	...
194:	// Logical operators and "nesting"
195:	int    age = 17;
196:	double iq  = 1.0;
197:	if (age >= 18 && iq > 90) {
198:	    // with "and" ("&&") BOTH have to be true
199:	}
200:	else if (age >= 18 || iq > 0) {
201:	    // with "or" ("||") EITHER can be true
202:	}
203:	else {
204:	    // Case if neither evaluates
205:	    if (age > 0) {
206:	        // A "nested if statement"
207:	    }
208:	}
209:	...
210:	// 3.6 Equivalent Boolean Expressions
211:	...
212:	Boolean (true/false) expressions turned into logical statements used by control structures 
213:	like conditional statements are subject to the laws of mathemtical logic such as "De Morgan's 
214:	Law" (Google search this if you are curious, but it applies to mathematical proofs and is 
215:	not necessarily applicable to this exam). This just means that complex statements need to be 
216:	evaluated by using mathematical rules (like "order of operations") and logical operators 
217:	(like "and, or, not") to determine the final Boolean result. This could determine if a 
218:	control structure (like an "if" statement) runs a block of code or not.
219:	...
220:	// 3.7 Comparing Objects
221:	...
222:	The use of an advanced data type like an "Object" in code means that comparison 
223:	operators (like <, >, ==, !=) that are used with primitive data type (like "int, 
224:	double, char, etc.") are not used. Instead, use the "built-in" method "equals()" to 
225:	determine the equality of two objects. For example:
226:	...
227:	// Use of the built-in equals method with Objects
228:	String word1 = "edgy";
229:	String word2 = "edGy";
230:	if (word1.equals(word2)) {
231:	    // "W1=W2"
232:	}
233:	else if (word1.equalsIgnoreCase(word2)) {
234:	    // "W1 kind of == W2"
235:	}
236:	...
237:	AP: Unit 3 (Boolean Expressions And If Statements) completed!..............................
238:	AP: Unit 4 (Iteration) started.............................................................
239:	// 4.1 while Loops
240:	// 4.2 for Loops
241:	// 4.3 Developing Algorithms Using Strings
242:	// 4.4 Nested Iteration
243:	// 4.5 Informal Code Analysis
244:	AP: Unit 4 (Iteration) completed!..........................................................
245:	AP curriculum - Part 1 Test completed!.....................................................
246:	AP curriculum - Part 2 Test started........................................................
247:	AP: Unit 2 (Using Objects) started.........................................................
248:	// 2.1 Objects: Instances of Classes
249:	// 2.2 Creating and Storing Objects (Instantiation)
250:	// 2.3 Calling a Void Method
251:	// 2.4 Calling a Void Method with Parameters
252:	// 2.5 Calling a Non-void Method
253:	// 2.6 String Objects: Concatenation, Literals, and More
254:	// 2.7 String Methods
255:	// 2.8 Wrapper Classes: Integer and Double
256:	// 2.9 Using the Math Class
257:	AP: Unit 2 (Using Objects) completed!......................................................
258:	AP: Unit 5 (Writing Classes) started.......................................................
259:	// 5.1 Anatomy of a Class
260:	// 5.2 Constructors
261:	// 5.2 Documentation with Comments
262:	// 5.4 Accessor Methods
263:	// 5.5 Mutator Methods
264:	// 5.6 Writing Methods
265:	// 5.7 Static Variables and Methods
266:	// 5.8 Scope and Access
267:	// 5.9 this Keyword
268:	// 5.10 Ethical and Social Implications of Computing Systems
269:	AP: Unit 5 (Writing Classes) completed!....................................................
270:	AP: Unit 9 (Inheritance) started...........................................................
271:	// 9.1 Creating Superclasses and Subclasses
272:	// 9.2 Writing Constructors for Subclasses
273:	// 9.3 Overriding Methods
274:	// 9.4 super Keyword
275:	// 9.5 Creating References Using Inheritance Hierarchies
276:	// 9.6 Polymorphism
277:	// 9.7 Object Superclass
278:	AP: Unit 9 (Inheritance) completed!........................................................
279:	AP curriculum - Part 2 Test completed!.....................................................
280:	AP curriculum - Part 3 Test started........................................................
281:	AP: Unit 6 (Arrays) started................................................................
282:	// 6.1 Array Creation and Access
283:	// 6.2 Traversing Arrays
284:	// 6.3 Enhanced for Loop for Arrays
285:	// 6.4 Developing Algorithms Using Arrays
286:	AP: Unit 6 (Arrays) completed!.............................................................
287:	AP: Unit 8 (2D Arrays) started.............................................................
288:	// 8.1 2D Arrays
289:	// 8.2 Traversing 2D Arrays
290:	AP: Unit 8 (2D Arrays) completed!..........................................................
291:	AP curriculum - Part 3 Test completed!.....................................................
292:	AP curriculum - Part 4 Test started........................................................
293:	AP: Unit 7 (Array List) started............................................................
294:	// 7.1 Introduction to ArrayList
295:	// 7.2 ArrayList Methods
296:	// 7.3 Traversing ArrayLists
297:	// 7.4 Developing Algorithms Using ArrayLists
298:	// 7.5 Searching
299:	// 7.6 Sorting
300:	// 7.7 Ethical Issues Around Data Collection
301:	AP: Unit 7 (Array List) completed!.........................................................
302:	AP: Unit 10 (Recursion ) started...........................................................
303:	// 10.1 Recursion
304:	// 10.2 Recursive Searching and Sorting
305:	AP: Unit 10 (Recursion ) completed!........................................................
306:	AP curriculum - Part 4 Test completed!.....................................................
307:	Computer Science 42SAP curriculum content complete!........................................
308:	Computer Science 42SAP complete!...........................................................
