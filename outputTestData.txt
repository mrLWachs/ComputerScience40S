1:	Mr. Wachs' Computer Science Classes........................................................
2:	Computer Science 42SAP Prerequisite content not running....................................
3:	Computer Science 42SAP Course:.............................................................
4:	Computer Science 42SAP curriculum content..................................................
5:	AP curriculum - Part 1.....................................................................
6:	AP: Unit 1 (Primitive Types)...............................................................
7:	1.1 Why Programming? Why Java?.............................................................
8:	System.out.print outputs text to the screen and System.out.println outputs with a line break
9:	More specifically, the code word "System" refers to the "computer system" and the 
10:	word "out" refers to outputting, and finally the word "print" or "println" are calls to 
11:	methods (or "actions") that take the string literal (which is the word or words in between 
12:	the quotation marks) and outputs it. So the command "System.out.println("literal");" 
13:	will take the string literal and output it to the default output device - that being the 
14:	computer screen.
15:	1.2 Variables and Data Types...............................................................
16:	Data/information refers to the "kind" of data being stored (or "remembered") by the program 
17:	in a "variable". A variable is a piece of the computer's memory (storage) that has a "name" 
18:	(or "address") so that the programmer can refer to it by that name. The "type" refers to the 
19:	"kind" of data that you are storing (e.g. text, numbers, true/false, etc.). The type must be 
20:	specified at the time you write a line of code to "create" (or "declare") the variable. A 
21:	variable can only be one type and only store that specified type of data. However, the data 
22:	itself can change (or "vary") after the initial declaration. Examples of this are below...
23:	// Variables declared and assigned initial ("starting") values:
24:	boolean a = true;
25:	int     b = 0;
26:	double  c = 1.0;
27:	char    d = 'A';
28:	// Variables content changes ("reassigned"):
29:	a = false;
30:	b = 1;
31:	c = 1.1;
32:	d = 'B';
33:	A "final" (or a "constant") is a variable in which the stored value does NOT change 
34:	(it stays "constant") and it locked at that value. Final (or constant) variables are 
35:	given the initial value when declared (or initialized) and that value stays locked. These 
36:	types of values are written in ALL_CAPS with the underscore value used to seperate words in 
37:	the name. Final variables are more efficient for a number of reasons including ease of code 
38:	understanding, speed (faster code), easier to update code, and others. Examples of finals 
39:	are below
40:	// Constants (finals) declared (initialized)
41:	final boolean FOUND  = true;
42:	final int     VALUE  = 1;
43:	final double  AMOUNT = 2.5;
44:	final char    CODE   = 'X';
45:	1.3 Expressions and Assignment Statements..................................................
46:	Arithmetic (or "math") statements in code are lines of code (or "statements") that are 
47:	written to evaluate (or "solve") an equation of logic the program needs to solve. In this 
48:	context, the word "literal" can also mean a number (like "5"). This usually involves 
49:	variable types int and double (the number types) used in a math expression or equation. This 
50:	can involve math operations like +, -, *, / and % (modulus). When multiple int values are 
51:	evaluated in a formula, they always evaluate to an int answer (solution) and double values 
52:	will evaluate to a double. Complex (or "compound" expressions can be formed in which 
53:	the order of operations (or precedence order). This means multiplication and division are 
54:	evaluated before addition and subtraction. If operations are at the same precedence level, 
55:	then they are evaluated from left to right.When you try and divide by zero, an error 
56:	(the "ArithmeticException" error) will occur and the program will stop running. Examples:
57:	// Arithmetic evaluations using variables
58:	int    v1 = 5;
59:	int    v2 = 3;
60:	int    v3 = (v1 + 5 * v2 / (1 + 2)) % 2;
61:	double v4 = 5.2;
62:	double v5 = 3.3;
63:	double v6 = (v4 + 5.1 * v5 / (1.2 + 2.3)) % 2.2;
64:	1.4 Compound Assignment Operators..........................................................
65:	Compound statements in this context refers to using shortcuts to quickly add or subtract one 
66:	(increment or decrement) to a variable. You can also use more complex shorthand compound 
67:	statements to quickly multiply, divide, even modulus a variable with itself or other 
68:	variables. For example:
69:	// Shorthand Compound Arithmetic expressions
70:	int value = 5;
71:	value++;    // is the same as "value = value + 1;"
72:	value--;    // is the same as "value = value + 1;"
73:	value += 5; // is the same as "value = value + 5;"
74:	value -= 5; // is the same as "value = value - 5;"
75:	value *= 5; // is the same as "value = value * 5;"
76:	value /= 5; // is the same as "value = value / 5;"
77:	value %= 5; // is the same as "value = value % 5;"
78:	1.5 Casting and Ranges of Variables........................................................
79:	Casting is the process of "converting" one data type into another data type. When casting 
80:	an double to a int, the decimal portion of the double is truncated (cut off) and not rounded 
81:	off. When a int is cast to a double, the int is "widened" to now accomodate any decimals. 
82:	A char when cast will turn into it's ASCII value. The process of casting involves putting 
83:	variable to be cast with the type being cast into in round brackets to the left of that 
84:	variable. Integer values hold a finite amount of number space (4 bytes) and the built-in 
85:	constants Integer.MAX_VALUE and MIN_VALUE are the limits of the int. If an expression 
86:	evaluates an int outside that range, an error will occur (overflow error). For example:
87:	// Casting data types
88:	int integer = Integer.MAX_VALUE;
89:	double doub = Double.MIN_VALUE;
90:	doub        = (int)integer;
91:	integer     = (int)doub;
92:	char letter = 'A';
93:	integer     = (int)letter;
94:	AP: Unit 3 (Boolean Expressions And If Statements).........................................
95:	3.1 Boolean Expressions....................................................................
96:	A Boolean (true/false) expression is a code statement most likely in a control structure 
97:	like a conditional statement or loop control structure that evaluates to true or false to 
98:	make decisions and control the flow of the program. The Boolean expression will require 
99:	the use of relational operators like: < , > , <= , >= , == , and != those being: "less 
100:	than", "greater than", "less than or equal to", "greater than or equal to", "equal 
101:	to", and "not equal to".
102:	3.2 if Statements and Control Flow.........................................................
103:	A "Conditional Statement" is also known under other names like "branching statement", "if 
104:	statement", "one-way selection statement", and "control structure". It uses the reserved 
105:	keyword "if" along with round brackets which contain the Boolean expression, and curly 
106:	brackets to contain the control block of all code you wish to be controlled by the 
107:	conditional statement. Brackets are optional if the block is only one line, and you may also 
108:	move thos lines up to the same line as the conditional statement. For example:
109:	// Example of if statements
110:	int a = 10;
111:	int b = 10;
112:	if (a == a) {
113:	    // "equal"
114:	}
115:	3.3 if-else Statements.....................................................................
116:	The "else" statement is paired with an "if" statement to control the flow of the logic so 
117:	that the conditional now evaluates to both true and false. This can be called a "two 
118:	way selection" (for true/false). An "else" must always follow an "if" statement first. 
119:	For example:
120:	// if with "else" 
121:	double c = 1.45, d = 1.5; 
122:	if (c < d) {
123:	    // "Less than"
124:	}
125:	else {
126:	    // "Greater than"
127:	}
128:	// Shortened lines version
129:	char e = 'A';
130:	char f = 'a';
131:	if (e != f) e = '!';
132:	else        e = '=';
133:	3.4 else if Statements.....................................................................
134:	When making multiple decisions (more than 2), the "else if" statement is added to an 
135:	existing "if" statement to have multiple branches of logic for the code to follow. This 
136:	is much more efficient than seperate "if" statements. This can also be called "multi-way 
137:	selection" (or "if-else-if"). An "else" statement is also still the final option (but 
138:	this is not required). For example:
139:	// Showing a "chain" of else if statements
140:	int g = 0;
141:	if (g == 1) {
142:	    // The first if is true
143:	}
144:	else if (g == 2) {
145:	    // The next if is true
146:	}
147:	else if (g == 3) {
148:	    // The next if (in the "chain" of ifs) is true
149:	}
150:	else {
151:	    // Nothing above is true, so go to this else
152:	}
153:	3.5 Compound Boolean Expressions...........................................................
154:	The process of "nesting" means to place one conditional statement inside the "block" of 
155:	another conditional statement. The logical operators: "and", "or", and "not" are 
156:	represented with the symbols: "&&" (and), "||" (or), and "!" (not). The operator AND 
157:	is used to combine logical boolean expressions such that ALL expressions need to be true for 
158:	the entire statement to be true. The operator OR is used to combine logical boolean 
159:	expressions such that ANY expression can be true for the entire statement to be true. The 
160:	operator NOT reverses the logic so that true statements are evaluated as false (and visa 
161:	versa). If the statement contains multiple Boolean expressions and the result of the 
162:	evaluation of one expression has already determined the expressions result, then the 
163:	rest of the expressions do not need to be evaluated - this is known as a "short-circuited 
164:	evaluation". For example:
165:	// Logical operators and "nesting"
166:	int    age = 17;
167:	double iq  = 1.0;
168:	if (age >= 18 && iq > 90) {
169:	    // with "and" ("&&") BOTH have to be true
170:	}
171:	else if (age >= 18 || iq > 0) {
172:	    // with "or" ("||") EITHER can be true
173:	}
174:	else {
175:	    // Case if neither evaluates
176:	    if (age > 0) {
177:	        // A "nested if statement"
178:	    }
179:	}
180:	3.6 Equivalent Boolean Expressions.........................................................
181:	Boolean (true/false) expressions turned into logical statements used by control structures 
182:	like conditional statements are subject to the laws of mathemtical logic such as "De Morgan's 
183:	Law" (Google search this if you are curious, but it applies to mathematical proofs and is 
184:	not necessarily applicable to this exam). This just means that complex statements need to be 
185:	evaluated by using mathematical rules (like "order of operations") and logical operators 
186:	(like "and, or, not") to determine the final Boolean result. This could determine if a 
187:	control structure (like an "if" statement) runs a block of code or not.
188:	3.7 Comparing Objects......................................................................
189:	The use of an advanced data type like an "Object" in code means that comparison 
190:	operators (like <, >, ==, !=) that are used with primitive data type (like "int, 
191:	double, char, etc.") are not used. Instead, use the "built-in" method "equals()" to 
192:	determine the equality of two objects. For example:
193:	// Use of the built-in equals method with Objects
194:	String word1 = "edgy";
195:	String word2 = "edGy";
196:	if (word1.equals(word2)) {
197:	    // "W1=W2"
198:	}
199:	else if (word1.equalsIgnoreCase(word2)) {
200:	    // "W1 kind of == W2"
201:	}
202:	AP: Unit 4 (Iteration).....................................................................
203:	4.1 while Loops............................................................................
204:	The word "Iteration" is another word for "Loop" or "Looping" which is a control 
205:	struture to have code statements "repeat". Like conditional ("if") statements, iteration 
206:	statements control the flow of a program's logic. Also like if statements, iteration 
207:	statements are controlled by a Boolean expression (true or false). The result of the Boolean 
208:	expression will result in the code executing zero or mulitple times (until the expression 
209:	evaluates to false). The expression is evaluated each time through an iteration of the loop. 
210:	A loop is called an "infinite" loop if the Boolean expression never evaluates to false 
211:	(thus the loop never stops looping - or never stops running). It is possible a loop will 
212:	never run if it evaluates to false before the body (block) of the loop. If you use the 
213:	keyword "return" inside a loop body (block) then the loop will terminate (end) early and 
214:	potentially exit any method the loop is written inside. The "while" loop is a event loop or 
215:	non-deterministic loop, which means it is not usually used for counting but when you do 
216:	not know how many times the loop needs to run (a certain event can cause the loop to 
217:	end). Loops are used for a variety of reasons such as: repeating instructions, travelling 
218:	(traversing) arrays and lists, and searching and sorting values. For example:
219:	// Example of a simple while loop
220:	int counter = 0;
221:	while (counter < 10) {
222:	    counter++;
223:	}
224:	4.2 for Loops..............................................................................
225:	The "for" loop is another looping form. The for loop is a count controlled loop that 
226:	generally is used when a loop needs to run a specific number of times. There are three 
227:	parts to the for loop, that seperate the parts with two semi-colons. The 3 parts represent 
228:	the starting, ending, and change of the loop. In a for loop a counting variable is 
229:	generally declared right inside the loop to a starting value, then the Boolean condition 
230:	to end the loop, then the change value increasing (increment) or decreasing (decrement) 
231:	that value. A "for" loop can be rewritten as a "while" loop and vice versa. A "off 
232:	by one" error occurs when a loop runs one too many or one too few times. For Example:
233:	// Example of a for loop
234:	for (int i = 0; i < 10; i++) {
235:	    // potential code body...
236:	}
237:	4.3 Developing Algorithms Using Strings....................................................
238:	The String class allows for several "built-in" methods of the String class to manipulate 
239:	the string and the value it stores. Several of these methods could apply to the A.P. exam 
240:	including travelling (traversing) string characters, pulling out substrings (parts 
241:	of the string), reversing a string, etc. For example:
242:	// Example of string methods with a loop
243:	String word   = "completion";
244:	String parts1 = word.substring(3);
245:	String parts2 = word.substring(1,7);
246:	for (int i = 0; i < word.length(); i++) {
247:	    char character = word.charAt(i);
248:	}
249:	4.4 Nested Iteration.......................................................................
250:	Like conditional ("if") statements, looping ("iteration") statments can be "nested", 
251:	This means you can place a iteration statement inside the block of another iteration 
252:	statement. The inner loop must complete all of its iterations before the outer loop 
253:	can continue. For example:
254:	// Example of nested loops
255:	for (int i = 0; i < 10; i++) {
256:	    for (int j = 0; j < 10; j++) {
257:	        int k = 10;
258:	        while (k < 10) {
259:	            // potential code body...
260:	        }
261:	    }
262:	}
263:	4.5 Informal Code Analysis.................................................................
264:	Expect to "trace" loop values in A.P. exam questions. Examining, computing, and tracing 
265:	loops are typical A.P. exam questions. You should practice these types of questions.
266:	AP curriculum - Part 2.....................................................................
267:	AP: Unit 2 (Using Objects).................................................................
268:	2.1 Objects: Instances of Classes..........................................................
269:	A "class" is the "blueprint" for creating an "object". In Java, the class is a way to 
270:	use code to model "things" using properties and methods. The object is what the class 
271:	"creates" when the class is made into a specific "object" of that class. The various 
272:	terms used for this vary but all revolve around the same concepts. The term "object" 
273:	can also be called a "instance" of the class. The term "properties" can also be 
274:	called "things about the class", or "descriptors", or "adjectives", or 
275:	"fields". The term "methods" could also be called "what the class can do", or 
276:	"actions", or "verbs", or "functions". 
277:	// Example of a simple class with properties and methods
278:	class Person {
279:	    String name;
280:	    int age;
281:	    void walk() {
282:	        // code logic could go here
283:	    }
284:	    void talk() {
285:	        // code logic could go here
286:	    }
287:	}
288:	2.2 Creating and Storing Objects (Instantiation)...........................................
289:	Methods are a way to break up code into logic modules and it also provides a way to avoid 
290:	repeating code and be able to reuse sections of code logic. You can think of methods as 
291:	analogous to "machines" that perform "actions" and you can reuse. They are also analogous to 
292:	"functions" in math that may take a variable "input" and generate an "answer".  The term 
293:	"parameter" (and you may have zero, one, or more than one) is the "input" (if needed) to a 
294:	method that is passed to the method. The value(s) passed are called "argument(s)". When you 
295:	define the method in the method "signature" line, the round brackets can contain 
296:	parameters separated by comma (if needed). A method may also give an "output" in the form 
297:	of its "return" value (which also might not be needed, in which case it is a "void" method).
298:	A method is "overloaded" if you have more than one method with the exact same name but 
299:	different parameters. Classes have "constructor" methods that are called when 
300:	a class is instantiated into an object. Constructor methods do not have a return type 
301:	(not even the keyword "void"). They must have the exact same name as the class (including a 
302:	capital letter). They are used to set the properties of the class to starting (or 
303:	"default") values. If a class has multiple constructor methods, they are said to be 
304:	overloaded constructors. When a line of code is used to instantiate a class into an instance 
305:	of that class, the line includes the name of the class, the identifier name of the object, 
306:	then an equals ("="), then the keyword "new" (which allots new memory for this 
307:	advanced data type), then a call to a constructor method. If not constructor method 
308:	is called, then the object references a "null" value until such time it is given a value to 
309:	reference.
310:	// Example of a class with constructors and instantiation
311:	class Person {
312:	    Person() {
313:	        // code logic
314:	    }
315:	    Person(int age) {
316:	        // code logic
317:	    }
318:	}
319:	Person person1 = new Person();
320:	Person person2 = new Person(5);
321:	2.3 Calling a Void Method..................................................................
322:	A "non-static" method is a method (meaning a "action", "behaviour", "procedure", 
323:	or "verb") that does not use the "static" modifier word in the method signature line. 
324:	A method with no prameters (or "inputs") means the method is defined with empty round 
325:	brackets "( )". The "behavior" or action the method performs is defined in the body 
326:	block of the method (between the two curly "{ }" brackets). The A.P. term "procedural 
327:	abstraction" refers to a programmer being able to call a method without knowing how the 
328:	method was written (also known as "black box" programming). When methods are "called" 
329:	the execution flow stops, jumps and runs all the method body (or until a "return" 
330:	statement) and then returns to the next line of execution after the method call line 
331:	(or part of a code expression line). Methods can also be called from objects (or 
332:	"instances") of a class using the dot "." operator. Void method do not return anthing 
333:	(no "outputs") and use the keyword modifier "void" in the method signature in place of 
334:	the return type.
335:	// Examples of methods, parameters, return, and calling
336:	public void show() {
337:	    System.out.println("*")
338:	}
339:	public void show(char value) {
340:	    System.out.println(value);
341:	}
342:	public int double(int number) {
343:	    return number * 2;
344:	} 
345:	show();
346:	show('A');
347:	int answer = double(5);
348:	2.4 Calling a Void Method with Parameters..................................................
349:	A "non-static void" methods with parameters is a method with no outputs, but has input(s). 
350:	This means the method signature has defined parameter(s) within the round brackets "( )" 
351:	seperated by commas (if necessary). When this type of method is called, the "arguments" 
352:	passed to this method must be in the same order in terms of data type. A method is 
353:	"overloaded" when you have two or more methods with the same name but different and 
354:	distinct parameter lists.
355:	// Examples of method overloading
356:	public void show() {
357:	    System.out.println("*")
358:	}
359:	public void show(char value) {
360:	    System.out.println(value);
361:	}
362:	public void show(int value) {
363:	    System.out.println(value);
364:	}
365:	2.5 Calling a Non-void Method..............................................................
366:	A method that does return a value, defines the return "type" in the method signature and 
367:	the keyword "return" somewhere in the method body (at least once). When calling a return 
368:	method, the value returned must be stored (in a variable) or used as part of an expression.
369:	2.6 String Objects: Concatenation, Literals, and More......................................
370:	The "String" class allows you to create String variables, concatenate them (join) 
371:	together and use "built-in" methods of the String class. String literals (contained in 
372:	quotes "") can be assigned to String variables or concatenated with Strings. String methods 
373:	do not change the String ("immutable") object. The "+" or the "+=" operators can be used 
374:	to concatenate Strings (resulting in a new String object). Primitives (like int, double, 
375:	etc.) can also be concatenated with String objects. Those are now automatically converted 
376:	to Strings and then concatenated. Escape sequences is the character "\" followed 
377:	by another character to make certain outputs or changes to a String object. These include: 
378:	\" for a quote, \\ for a slash, and \n for a new line.
379:	// Examples of Strings and escape sequences
380:	String str1 = "cat";
381:	String str2 = str1 + "ty";
382:	str1 += str2;
383:	str2 = "\n" + str1 + "\\" + "\" dog";
384:	2.7 String Methods.........................................................................
385:	The "API" or Application Program Interface is a "library" of code that could be imported 
386:	into a Java project or it could automatically be part of every Java project without needing 
387:	an import. Classes and libraries are organized into "packages" in Java (also known as 
388:	"namespaces"). The String class is in the "java.lang" package. Strings are collections 
389:	of "char" values index from 0 up to the length of the String minus 1 (just like arrays 
390:	are indexed). String methods used are: the String constructor "String s = new String();", 
391:	the "length()" method, the "substring(int)" and "substring(int,int)" methods, the 
392:	"indexOf(String)" method, the "equals(String)" method, and the 
393:	"compareTo(String)" method.
394:	// Examples of String methods
395:	String str3 = new String("chatty");
396:	// Constructs object with same sequence of characters as str3
397:	int length = str3.length();
398:	// Returns the number of characters in a String object
399:	String str4 = str3.substring(1);
400:	// Returns substring(from) starting at index "from" to the end
401:	String str5 = str3.substring(1,3);
402:	// Returns substring(from, to) starting at index "from" to index "to"
403:	int index = str3.indexOf("hat");
404:	// Returns the index of the first occurrence (returns -1 if not found)
405:	boolean result1 = str3.equals(str4);
406:	// Returns true if this is equal to other (returns false otherwise)
407:	int result2 = str3.compareTo(str5);
408:	// Returns value < 0 if less than other, returns 0 if equal to other,
409:	// and returns value > 0 if greater than other
410:	2.8 Wrapper Classes: Integer and Double....................................................
411:	A "wrapper class" is a class type that is based in a primitive data type. For example the 
412:	primitive data type "int" has the wrapper class "Integer". Similarily, the "Double" 
413:	wrapper class, wraps around the "double" primitive type. The wrapper classes (using a 
414:	capital letter) are part of java.lang and have built-in methods like "parseInt()" and 
415:	"parseDouble()". Other methods include: "Integer(int)" a constructor, 
416:	"Double(double)" a constructor, "MIN_VALUE" a constant, "MAX_VALUE", "intValue()", and 
417:	"doubleValue()". Boxing and unboxing can be done between the wrapper classes and the 
418:	primitive types (known as "autoboxing"). The term "boxing" means the conversion between 
419:	primitive types and corresponding wrapper. The term "unboxing" means the conversion 
420:	from the wrapper class to the primitive type.
421:	// Example of wrapper classes and methods...
422:	int     integerPrimitive1 = Integer.parseInt("10");
423:	double  doublePrimitive1  = Double.parseDouble("1.2");
424:	Integer integerObject     = new Integer("10");
425:	Double  doubleObject      = new Double("1.2");
426:	int     integerPrimitive2 = integerObject.intValue();
427:	double  doublePrimitive2  = doubleObject.doubleValue();
428:	int     minInteger        = Integer.MIN_VALUE;
429:	int     maxInteger        = Integer.MAX_VALUE;
430:	double  minDouble         = Double.MIN_VALUE;
431:	double  maxDouble         = Double.MAX_VALUE;
432:	// Boxing and unboxing...
433:	int     integerPrimitive3 = integerObject1;
434:	double  doublePrimitive3  = doubleObject1;
435:	Integer integerObject2    = integerPrimitive3;
436:	Double  doubleObject2     = doublePrimitive3;
437:	2.9 Using the Math Class...................................................................
438:	The "Math" class is part of the java.lang package and has built-in static methods that can 
439:	be called. Useful methods include: abs, pow, sqrt, and random. Including manipulating the 
440:	random method in a formula to define random numbers in a range. Examples of this follow...
441:	// Examples of the Math class methods and randoms...
442:	int    value1 = Math.abs(-1);
443:	double value2 = Math.abs(-1.2);
444:	double value3 = Math.pow(2,3);
445:	double value4 = Math.sqrt(9);
446:	double value5 = Math.random();
447:	final double HIGH = 10.9d;
448:	final double LOW  = 5.5d;
449:	double value6 = (HIGH - LOW + 1.0d) * Math.random() + LOW;
450:	AP: Unit 5 (Writing Classes)...............................................................
451:	5.1 Anatomy of a Class.....................................................................
452:	The properties (attributes) and methods (actions) of a class can be defined in terms of 
453:	visibility. This means that the keywords "public" and "private" can be used as a 
454:	modifier in the front of a method signature or at the front of a property declaration line 
455:	to define the encapsulation level. The public keyword means the property can be accessed (and 
456:	modified) both inside the class and from other classes outside the class. In terms of methods 
457:	it means the method can be called within the class (by other methods) and outside the class 
458:	from other classes using the dot "." operator. Classes and constructor methods are 
459:	designated public. The concept of "encapsulation" is used to make certain data and actions 
460:	private and protect them from outside classes and perhaps only allow access through accessor 
461:	and modifier ("getter" and "setter") methods.
462:	// Class example private/public properties and methods
463:	class Apple { 
464:	    public int number;
465:	    private double price;
466:	    public void eat() {
467:	        // logic here
468:	    }
469:	    private void spoil() {
470:	        // logic here
471:	    }
472:	}
473:	5.2 Constructors...........................................................................
474:	A constructor method is a special method defined in a class that is called when a class is 
475:	instantiated into an instance (or "object") of that class. The constructor method has to have 
476:	the exact same name as the class (including letter case) and no return type (not even the 
477:	word void). Constructors are usually used to set the initial (or "default") values for the 
478:	class properties. This can be said to be setting the "state" of the object. If any of the 
479:	properties (attributes) are another class level instance variable (not a primitive type), 
480:	then this class is said to have a "has-a" relationship with that class. This can also be 
481:	called "association" or "composition" between the classes. Constructors can have 
482:	parameters passed to the class that can be used in setting the initial state. When no 
483:	constructor is written, Java provides a no-argument constructor, and the instance 
484:	variables are set to default values.
485:	// Class example association and constructors
486:	class Basket {
487:	    public Apple apple;
488:	    public Basket() {
489:	        // logic here
490:	    }
491:	    public Basket(Apple apple) {
492:	        // logic here
493:	    }
494:	}
495:	5.2 Documentation with Comments............................................................
496:	...
497:	// 
498:	5.4 Accessor Methods.......................................................................
499:	...
500:	// 
501:	5.5 Mutator Methods........................................................................
502:	...
503:	// 
504:	5.6 Writing Methods........................................................................
505:	...
506:	// 
507:	5.7 Static Variables and Methods...........................................................
508:	...
509:	// 
510:	5.8 Scope and Access.......................................................................
511:	...
512:	// 
513:	5.9 this Keyword...........................................................................
514:	...
515:	// 
516:	5.10 Ethical and Social Implications of Computing Systems..................................
517:	...
518:	// 
519:	AP: Unit 9 (Inheritance) not running.......................................................
520:	AP curriculum - Part 3 not running.........................................................
521:	AP curriculum - Part 4 not running.........................................................
522:	Computer Science 42SAP practice tests not running..........................................
523:	Computer Science 42SAP Post Secondary content not running..................................
