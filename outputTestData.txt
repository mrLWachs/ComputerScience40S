1:	Mr. Wachs Computer Science testing started.................................................
2:	Computer Science 42SAP starting............................................................
3:	Computer Science 42SAP curriculum content starting.........................................
4:	AP curriculum - Part 1 Test started........................................................
5:	AP: Unit 1 (Primitive Types) started.......................................................
6:	1.1 Why Programming? Why Java?
7:	System.out.print outputs text to the screen and System.out.println outputs with a line break
8:	More specifically, the code word "System" refers to the "computer system" and the 
9:	word "out" refers to outputting, and finally the word "print" or "println" are calls to 
10:	methods (or "actions") that take the string literal (which is the word or words in between 
11:	the quotation marks) and outputs it. So the command "System.out.println("literal");" 
12:	will take the string literal and output it to the default output device - that being the 
13:	computer screen.
14:	1.2 Variables and Data Types
15:	Data/information refers to the "kind" of data being stored (or "remembered") by the program 
16:	in a "variable". A variable is a piece of the computer's memory (storage) that has a "name" 
17:	(or "address") so that the programmer can refer to it by that name. The "type" refers to the 
18:	"kind" of data that you are storing (e.g. text, numbers, true/false, etc.). The type must be 
19:	specified at the time you write a line of code to "create" (or "declare") the variable. A 
20:	variable can only be one type and only store that specified type of data. However, the data 
21:	itself can change (or "vary") after the initial declaration. Examples of this are below...
22:	Variables declared and assigned initial ("starting") values:
23:	boolean a = true;
24:	int     b = 0;
25:	double  c = 1.0;
26:	char    d = 'A';
27:	Variables content changes ("reassigned"):
28:	a = false;
29:	b = 1;
30:	c = 1.1;
31:	d = 'B';
32:	A "final" (or a "constant") is a variable in which the stored value does NOT change 
33:	(it stays "constant") and it locked at that value. Final (or constant) variables are 
34:	given the initial value when declared (or initialized) and that value stays locked. These 
35:	types of values are written in ALL_CAPS with the underscore value used to seperate words in 
36:	the name. Final variables are more efficient for a number of reasons including ease of code 
37:	understanding, speed (faster code), easier to update code, and others. Examples of finals 
38:	are below
39:	Constants (finals) declared (initialized)
40:	final boolean FOUND  = true;
41:	final int     VALUE  = 1;
42:	final double  AMOUNT = 2.5;
43:	final char    CODE   = 'X';
44:	1.3 Expressions and Assignment Statements
45:	Arithmetic (or "math") statements in code are lines of code (or "statements") that are 
46:	written to evaluate (or "solve") an equation of logic the program needs to solve. In this 
47:	context, the word "literal" can also mean a number (like "5"). This usually involves 
48:	variable types int and double (the number types) used in a math expression or equation. This 
49:	can involve math operations like +, -, *, / and % (modulus). When multiple int values are 
50:	evaluated in a formula, they always evaluate to an int answer (solution) and double values 
51:	will evaluate to a double. Complex (or "compound" expressions can be formed in which 
52:	the order of operations (or precedence order). This means multiplication and division are 
53:	evaluated before addition and subtraction. If operations are at the same precedence level, 
54:	then they are evaluated from left to right.When you try and divide by zero, an error 
55:	(the "ArithmeticException" error) will occur and the program will stop running. Examples:
56:	Arithmetic evaluations using variables
57:	int    v1 = 5;
58:	int    v2 = 3;
59:	int    v3 = (v1 + 5 * v2 / (1 + 2)) % 2;
60:	double v4 = 5.2;
61:	double v5 = 3.3;
62:	double v6 = (v4 + 5.1 * v5 / (1.2 + 2.3)) % 2.2;
63:	1.4 Compound Assignment Operators
64:	Compound statements in this context refers to using shortcuts to quickly add or subtract one 
65:	(increment or decrement) to a variable. You can also use more complex shorthand compound 
66:	statements to quickly multiply, divide, even modulus a variable with itself or other 
67:	variables. For example:
68:	Shorthand Compound Arithmetic expressions
69:	int value = 5;
70:	value++;    // is the same as "value = value + 1;"
71:	value--;    // is the same as "value = value + 1;"
72:	value += 5; // is the same as "value = value + 5;"
73:	value -= 5; // is the same as "value = value - 5;"
74:	value *= 5; // is the same as "value = value * 5;"
75:	value /= 5; // is the same as "value = value / 5;"
76:	value %= 5; // is the same as "value = value % 5;"
77:	1.5 Casting and Ranges of Variables
78:	Casting is the process of "converting" one data type into another data type. When casting 
79:	an double to a int, the decimal portion of the double is truncated (cut off) and not rounded 
80:	off. When a int is cast to a double, the int is "widened" to now accomodate any decimals. 
81:	A char when cast will turn into it's ASCII value. The process of casting involves putting 
82:	variable to be cast with the type being cast into in round brackets to the left of that 
83:	variable. Integer values hold a finite amount of number space (4 bytes) and the built-in 
84:	constants Integer.MAX_VALUE and MIN_VALUE are the limits of the int. If an expression 
85:	evaluates an int outside that range, an error will occur (overflow error). For example:
86:	Casting data types
87:	int integer = Integer.MAX_VALUE;
88:	double doub = Double.MIN_VALUE;
89:	doub        = (int)integer;
90:	integer     = (int)doub;
91:	char letter = 'A';
92:	integer     = (int)letter;
93:	AP: Unit 1 (Primitive Types) completed!....................................................
94:	AP: Unit 3 (Boolean Expressions And If Statements) started.................................
95:	3.1 Boolean Expressions
96:	A Boolean (true/false) expression is a code statement most likely in a control structure 
97:	like a conditional statement or loop control structure that evaluates to true or false to 
98:	make decisions and control the flow of the program. The Boolean expression will require 
99:	the use of relational operators like: < , > , <= , >= , == , and != those being: "less 
100:	than", "greater than", "less than or equal to", "greater than or equal to", "equal 
101:	to", and "not equal to".
102:	3.2 if Statements and Control Flow
103:	A "Conditional Statement" is also known under other names like "branching statement", "if 
104:	statement", "one-way selection statement", and "control structure". It uses the reserved 
105:	keyword "if" along with round brackets which contain the Boolean expression, and curly 
106:	brackets to contain the control block of all code you wish to be controlled by the 
107:	conditional statement. Brackets are optional if the block is only one line, and you may also 
108:	move thos lines up to the same line as the conditional statement. For example:
109:	Example of if statements
110:	int a = 10;
111:	int b = 10;
112:	if (a == a) {
113:	    // "equal"
114:	}
115:	3.3 if-else Statements
116:	The "else" statement is paired with an "if" statement to control the flow of the logic so 
117:	that the conditional now evaluates to both true and false. This can be called a "two 
118:	way selection" (for true/false). An "else" must always follow an "if" statement first. 
119:	For example:
120:	if with "else" 
121:	double c = 1.45, d = 1.5; 
122:	if (c < d) {
123:	    // "Less than"
124:	}
125:	else {
126:	    // "Greater than"
127:	}
128:	Shortened lines version
129:	char e = 'A';
130:	char f = 'a';
131:	if (e != f) e = '!';
132:	else        e = '=';
133:	3.4 else if Statements
134:	When making multiple decisions (more than 2), the "else if" statement is added to an 
135:	existing "if" statement to have multiple branches of logic for the code to follow. This 
136:	is much more efficient than seperate "if" statements. This can also be called "multi-way 
137:	selection" (or "if-else-if"). An "else" statement is also still the final option (but 
138:	this is not required). For example:
139:	Showing a "chain" of else if statements
140:	int g = 0;
141:	if (g == 1) {
142:	    // The first if is true
143:	}
144:	else if (g == 2) {
145:	    // The next if is true
146:	}
147:	else if (g == 3) {
148:	    // The next if (in the "chain" of ifs) is true
149:	}
150:	else {
151:	    // Nothing above is true, so go to this else
152:	}
153:	3.5 Compound Boolean Expressions
154:	The process of "nesting" means to place one conditional statement inside the "block" of 
155:	another conditional statement. The logical operators: "and", "or", and "not" are 
156:	represented with the symbols: "&&" (and), "||" (or), and "!" (not). The operator AND 
157:	is used to combine logical boolean expressions such that ALL expressions need to be true for 
158:	the entire statement to be true. The operator OR is used to combine logical boolean 
159:	expressions such that ANY expression can be true for the entire statement to be true. The 
160:	operator NOT reverses the logic so that true statements are evaluated as false (and visa 
161:	versa). If the statement contains multiple Boolean expressions and the result of the 
162:	evaluation of one expression has already determined the expressions result, then the 
163:	rest of the expressions do not need to be evaluated - this is known as a "short-circuited 
164:	evaluation". For example:
165:	Logical operators and "nesting"
166:	int    age = 17;
167:	double iq  = 1.0;
168:	if (age >= 18 && iq > 90) {
169:	    // with "and" ("&&") BOTH have to be true
170:	}
171:	else if (age >= 18 || iq > 0) {
172:	    // with "or" ("||") EITHER can be true
173:	}
174:	else {
175:	    // Case if neither evaluates
176:	    if (age > 0) {
177:	        // A "nested if statement"
178:	    }
179:	}
180:	3.6 Equivalent Boolean Expressions
181:	Boolean (true/false) expressions turned into logical statements used by control structures 
182:	like conditional statements are subject to the laws of mathemtical logic such as "De Morgan's 
183:	Law" (Google search this if you are curious, but it applies to mathematical proofs and is 
184:	not necessarily applicable to this exam). This just means that complex statements need to be 
185:	evaluated by using mathematical rules (like "order of operations") and logical operators 
186:	(like "and, or, not") to determine the final Boolean result. This could determine if a 
187:	control structure (like an "if" statement) runs a block of code or not.
188:	3.7 Comparing Objects
189:	The use of an advanced data type like an "Object" in code means that comparison 
190:	operators (like <, >, ==, !=) that are used with primitive data type (like "int, 
191:	double, char, etc.") are not used. Instead, use the "built-in" method "equals()" to 
192:	determine the equality of two objects. For example:
193:	Use of the built-in equals method with Objects
194:	String word1 = "edgy";
195:	String word2 = "edGy";
196:	if (word1.equals(word2)) {
197:	    // "W1=W2"
198:	}
199:	else if (word1.equalsIgnoreCase(word2)) {
200:	    // "W1 kind of == W2"
201:	}
202:	AP: Unit 3 (Boolean Expressions And If Statements) completed!..............................
203:	AP: Unit 4 (Iteration) started.............................................................
204:	4.1 while Loops
205:	The word "Iteration" is another word for "Loop" or "Looping" which is a control 
206:	struture to have code statements "repeat". Like conditional ("if") statements, iteration 
207:	statements control the flow of a program's logic. Also like if statements, iteration 
208:	statements are controlled by a Boolean expression (true or false). The result of the Boolean 
209:	expression will result in the code executing zero or mulitple times (until the expression 
210:	evaluates to false). The expression is evaluated each time through an iteration of the loop. 
211:	A loop is called an "infinite" loop if the Boolean expression never evaluates to false 
212:	(thus the loop never stops looping - or never stops running). It is possible a loop will 
213:	never run if it evaluates to false before the body (block) of the loop. If you use the 
214:	keyword "return" inside a loop body (block) then the loop will terminate (end) early and 
215:	potentially exit any method the loop is written inside. The "while" loop is a event loop or 
216:	non-deterministic loop, which means it is not usually used for counting but when you do 
217:	not know how many times the loop needs to run (a certain event can cause the loop to 
218:	end). Loops are used for a variety of reasons such as: repeating instructions, travelling 
219:	(traversing) arrays and lists, and searching and sorting values. For example:
220:	Example of a simple while loop
221:	int counter = 0;
222:	while (counter < 10) {
223:	    counter++;
224:	}
225:	4.2 for Loops
226:	The "for" loop is another looping form. The for loop is a count controlled loop that 
227:	generally is used when a loop needs to run a specific number of times. There are three 
228:	parts to the for loop, that seperate the parts with two semi-colons. The 3 parts represent 
229:	the starting, ending, and change of the loop. In a for loop a counting variable is 
230:	generally declared right inside the loop to a starting value, then the Boolean condition 
231:	to end the loop, then the change value increasing (increment) or decreasing (decrement) 
232:	that value. A "for" loop can be rewritten as a "while" loop and vice versa. A "off 
233:	by one" error occurs when a loop runs one too many or one too few times. For Example:
234:	Example of a for loop
235:	for (int i = 0; i < 10; i++) {
236:	    // potential code body...
237:	}
238:	4.3 Developing Algorithms Using Strings
239:	...
240:	The String class allows for several "built-in" methods of the String class to manipulate 
241:	the string and the value it stores. Several of these methods could apply to the A.P. exam 
242:	including travelling (traversing) string characters, pulling out substrings (parts 
243:	of the string), reversing a string, etc. For example:
244:	Example of string methods with a loop
245:	String word   = "completion";
246:	String parts1 = word.substring(3);
247:	String parts2 = word.substring(1,7);
248:	for (int i = 0; i < word.length(); i++) {
249:	    char character = word.charAt(i);
250:	}
251:	4.4 Nested Iteration
252:	Like conditional ("if") statements, looping ("iteration") statments can be "nested", 
253:	This means you can place a iteration statement inside the block of another iteration 
254:	statement. The inner loop must complete all of its iterations before the outer loop 
255:	can continue. For example:
256:	Example of nested loops
257:	for (int i = 0; i < 10; i++) {
258:	    for (int j = 0; j < 10; j++) {
259:	        int k = 10;
260:	        while (k < 10) {
261:	            // potential code body...
262:	        }
263:	    }
264:	}
265:	4.5 Informal Code Analysis
266:	Expect to "trace" loop values in A.P. exam questions. Examining, computing, and tracing 
267:	loops are typical A.P. exam questions. You should practice these types of questions.
268:	AP: Unit 4 (Iteration) completed!..........................................................
269:	AP curriculum - Part 1 Test completed!.....................................................
270:	AP curriculum - Part 2 Test started........................................................
271:	AP: Unit 2 (Using Objects) started.........................................................
272:	2.1 Objects: Instances of Classes
273:	2.2 Creating and Storing Objects (Instantiation)
274:	2.3 Calling a Void Method
275:	2.4 Calling a Void Method with Parameters
276:	2.5 Calling a Non-void Method
277:	2.6 String Objects: Concatenation, Literals, and More
278:	2.7 String Methods
279:	2.8 Wrapper Classes: Integer and Double
280:	2.9 Using the Math Class
281:	AP: Unit 2 (Using Objects) completed!......................................................
282:	AP: Unit 5 (Writing Classes) started.......................................................
283:	5.1 Anatomy of a Class
284:	5.2 Constructors
285:	5.2 Documentation with Comments
286:	5.4 Accessor Methods
287:	5.5 Mutator Methods
288:	5.6 Writing Methods
289:	5.7 Static Variables and Methods
290:	5.8 Scope and Access
291:	5.9 this Keyword
292:	5.10 Ethical and Social Implications of Computing Systems
293:	AP: Unit 5 (Writing Classes) completed!....................................................
294:	AP: Unit 9 (Inheritance) started...........................................................
295:	9.1 Creating Superclasses and Subclasses
296:	9.2 Writing Constructors for Subclasses
297:	9.3 Overriding Methods
298:	9.4 super Keyword
299:	9.5 Creating References Using Inheritance Hierarchies
300:	9.6 Polymorphism
301:	9.7 Object Superclass
302:	AP: Unit 9 (Inheritance) completed!........................................................
303:	AP curriculum - Part 2 Test completed!.....................................................
304:	AP curriculum - Part 3 Test started........................................................
305:	AP: Unit 6 (Arrays) started................................................................
306:	6.1 Array Creation and Access
307:	6.2 Traversing Arrays
308:	6.3 Enhanced for Loop for Arrays
309:	6.4 Developing Algorithms Using Arrays
310:	AP: Unit 6 (Arrays) completed!.............................................................
311:	AP: Unit 8 (2D Arrays) started.............................................................
312:	8.1 2D Arrays
313:	8.2 Traversing 2D Arrays
314:	AP: Unit 8 (2D Arrays) completed!..........................................................
315:	AP curriculum - Part 3 Test completed!.....................................................
316:	AP curriculum - Part 4 Test started........................................................
317:	AP: Unit 7 (Array List) started............................................................
318:	7.1 Introduction to ArrayList
319:	7.2 ArrayList Methods
320:	7.3 Traversing ArrayLists
321:	7.4 Developing Algorithms Using ArrayLists
322:	7.5 Searching
323:	7.6 Sorting
324:	7.7 Ethical Issues Around Data Collection
325:	AP: Unit 7 (Array List) completed!.........................................................
326:	AP: Unit 10 (Recursion ) started...........................................................
327:	10.1 Recursion
328:	10.2 Recursive Searching and Sorting
329:	AP: Unit 10 (Recursion ) completed!........................................................
330:	AP curriculum - Part 4 Test completed!.....................................................
331:	Computer Science 42SAP curriculum content complete!........................................
332:	Computer Science 42SAP complete!...........................................................
